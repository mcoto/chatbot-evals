Perfecto â€” te puedo preparar una documentaciÃ³n tÃ©cnica completa que describa **quÃ© hace el sistema, cÃ³mo estÃ¡ implementado y cÃ³mo interactÃºan sus componentes**, con todo el detalle posible segÃºn lo que tenemos hasta ahora.
La estructurarÃ­a asÃ­ para que sirva tanto a desarrolladores como a evaluadores:

---

# ğŸ“„ Chatbot Eval Lab â€“ Technical Documentation

## 1. Overview

**Chatbot Eval Lab** es un entorno de referencia para experimentar con **evaluaciÃ³n de chatbots empresariales** bajo condiciones reales, en lÃ­nea con el paper acadÃ©mico *Towards Reliable Evaluation of Enterprise Chatbots under Real-World Constraints*.

Este entorno implementa:

* **Un chatbot multi-fuente** que combina datos internos en tiempo real (APIs internas), informaciÃ³n documental vÃ­a **RAG (Retrieval-Augmented Generation)** y, opcionalmente, un LLM.
* **Un ground truth vivo** que cambia con el tiempo, permitiendo evaluar mÃ©tricas sobre datos actualizados.
* **Una interfaz web** para interactuar con el chatbot.
* **Servicios simulados de negocio** para pedidos, facturaciÃ³n, inventario y polÃ­ticas.
* **Persistencia en Qdrant** para documentos RAG y en PostgreSQL para datos transaccionales.
* **Infraestructura en Docker Compose** para ejecutar todo el stack.

---

## 2. System Architecture

```
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚        Web UI             â”‚
                   â”‚ (React + API Gateway)     â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                      REST over HTTP (JSON)
                                 â”‚
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚        chatbot (FastAPI)     â”‚
                  â”‚ - Orquestrador               â”‚
                  â”‚ - Consulta APIs internas     â”‚
                  â”‚ - Consulta RAG/Qdrant        â”‚
                  â”‚ - Formatea respuestas        â”‚
                  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                          â”‚               â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                                             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Business APIs (FastAPI)     â”‚             â”‚   RAG Backend                 â”‚
â”‚ - orders-api                 â”‚             â”‚ - Qdrant (vector DB)          â”‚
â”‚ - billing-api                â”‚             â”‚ - retriever.py (ingest/query) â”‚
â”‚ - inventory-api              â”‚             â”‚                               â”‚
â”‚ - policy-api                 â”‚             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3. Components

### 3.1 `chatbot` (FastAPI)

* **Rol**: Orquestar las consultas a APIs internas, ejecutar bÃºsquedas RAG y ensamblar la respuesta final.
* **Endpoints principales**:

  * `GET /health`: chequeo de estado.
  * `POST /chat`: recibe un mensaje del usuario y parÃ¡metros opcionales (`order_id`, `sku`, `lang`).
  * `POST /admin/rag/ingest`: ingesta masiva de documentos a Qdrant con metadatos (protegido por `X-Admin-Token`).
* **Funciones clave**:

  * Uso de `httpx.AsyncClient` para consultas concurrentes a APIs.
  * InterpretaciÃ³n de intenciÃ³n simple mediante bÃºsqueda de palabras clave.
  * Enriquecimiento de respuesta con RAG si se detecta la necesidad.

### 3.2 `retriever.py`

* **Rol**: Abstraer operaciones con Qdrant (vector DB).
* **Funciones**:

  * `ingest(docs)`: procesa y guarda embeddings con metadatos.
  * `search(query, top_k, filters)`: consulta documentos relevantes segÃºn similaridad y filtros (ej. SKU).
* **Uso en chatbot**: llamado desde `/chat` y `/admin/rag/ingest`.

### 3.3 Business APIs simuladas

Todas implementadas con **FastAPI**:

* `orders-api`: devuelve informaciÃ³n de pedidos (`status`, `eta`, `id`).
* `billing-api`: facturas asociadas a pedidos (`amount`, `currency`, `due_date`).
* `inventory-api`: stock y precio por SKU.
* `policy-api`: textos de polÃ­ticas aplicables (ej. clÃ¡usulas por retrasos).

Cada API expone:

* `GET /health`
* Endpoints especÃ­ficos de recurso (ej. `/orders/{id}`).

### 3.4 Bases de datos

* **PostgreSQL (`gt-db`)**: almacena datos estructurados de pedidos, facturas, inventario y polÃ­ticas.
* **Qdrant (`rag-qdrant`)**: base de datos vectorial para contenido documental enriquecido (metadatos + embeddings).

### 3.5 Web UI

* **Rol**: interfaz de interacciÃ³n con el chatbot.
* Construida como aplicaciÃ³n React (`eval-ui`).
* Consume `/chat` vÃ­a HTTP.
* No contiene la lÃ³gica del chatbot, solo presenta y envÃ­a mensajes.

---

## 4. Data Flow

1. **Usuario envÃ­a mensaje** desde Web UI o API (`POST /chat`).
2. `chatbot`:

   * Detecta intenciÃ³n (pedidos, facturas, inventario, documentos tÃ©cnicos).
   * Llama a APIs internas correspondientes.
   * Si aplica, consulta RAG vÃ­a `retriever.search`.
   * Combina respuestas en texto final.
3. **Respuesta devuelta** con:

   * `response`: texto listo para mostrar.
   * `tools_used`: lista de servicios invocados.
   * `evidence`: datos crudos devueltos por las APIs y RAG.
4. **UI** renderiza el mensaje.

---

## 5. RAG Implementation Details

* **Qdrant** como vector DB, ejecutÃ¡ndose en un contenedor Docker (`rag-qdrant`).
* **Ingesta**:

  * Archivos `.md` y `.txt` ubicados en `/app/data/rag_corpus`.
  * Soporta *front matter YAML* para metadatos: `sku`, `source`, `lang`, `valid_from`, `valid_to`, `tags`.
  * Almacenados con embeddings generados (modelo a definir).
* **Consulta**:

  * Filtrado opcional por SKU u otros metadatos.
  * Retorna top-k documentos, ordenados por similaridad.
  * El chatbot integra el primer resultado al mensaje.

---

## 6. Docker & Deployment

### 6.1 Docker Compose

* Un solo `docker-compose.yml` orquesta:

  * `chatbot`
  * `orders-api`, `billing-api`, `inventory-api`, `policy-api`
  * `gt-db` (PostgreSQL con datos precargados)
  * `rag-qdrant` (almacenamiento vectorial)
  * `eval-ui` (interfaz web)

### 6.2 VolÃºmenes

* `chatbot-eval-lab_pgdata`: datos persistentes de PostgreSQL.
* `chatbot-eval-lab_qdrant_storage`: datos persistentes de Qdrant.
* `chatbot-eval-lab_ollama_models`: modelos descargados (opcional, si se integra LLM local).

### 6.3 Redes

* Una red interna de Docker para comunicaciÃ³n entre contenedores.
* Servicios accesibles desde `chatbot` por nombre de host (`orders-api`, `rag-qdrant`, etc.).

---

## 7. Current Limitations

* El chatbot actualmente **no invoca un LLM** para generar lenguaje natural â€” la respuesta es armada manualmente con datos estructurados y texto fijo.
* RAG implementado pero pendiente de integrar un generador de embeddings.
* MÃ©tricas de evaluaciÃ³n aÃºn no implementadas â€” prÃ³ximo paso segÃºn el paper.
* Seguridad bÃ¡sica: solo `/admin/rag/ingest` protegido por token.

---

## 8. Next Steps

* Integrar LLM (local vÃ­a Ollama o API externa) para enriquecer respuestas.
* Implementar mÃ³dulo de **evaluaciÃ³n automÃ¡tica** con mÃ©tricas del paper (factualidad, completitud, tiempo de respuesta, etc.).
* Ampliar ground truth vivo con mÃ¡s casos de negocio.
* AÃ±adir autenticaciÃ³n en todos los endpoints.
* Scripts de ingestiÃ³n automÃ¡tica y dataset de prueba para reproducibilidad.

---

Si quieres, te puedo preparar tambiÃ©n un **README.md extendido** con esta misma informaciÃ³n pero formateada para GitHub, incluyendo diagramas en Mermaid para que se vean en el repo.

Â¿Quieres que lo haga en ese formato?

